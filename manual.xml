<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
		<meta charset='utf-8' /> 
		<title>gamelab</title>
		<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" />
		<link rel="stylesheet" href="manual.css" type="text/css" />
	</head>
	<body>
		<header>
			<a href="index.html"><img src="logo.png" alt="Gamelab Logo" /></a>
			<h1><a href="index.html">gamelab</a></h1>
		</header>
		<nav>
			<span>Version @VERSION@</span>
			<span>
				<a href="mailto:kristaps@kcons.eu">Contact</a>
				<a title="Contact" href="mailto:kristaps@kcons.eu"><i class="fa fa-envelope-o"></i></a>
			</span>
			<!-- span>
				<span>Source</span>
				<a title="Source Code" href="snapshots/gamelab.tgz"><i class="fa fa-gears"></i></a>
				<a title="Source Checksum" href="snapshots/gamelab.tgz.sha512"><i class="fa fa-lock"></i></a>
				<a title="Source Archive" href="snapshots"><i class="fa fa-archive"></i></a>
			</span -->
			<span>
				<a href="gamelab.bib">Cite</a>
				<a title="BibTeX Citation" href="gamelab.bib"><i class="fa fa-bookmark"></i></a>
			</span>
		</nav>
		<article>
			<p>
				<span class="nm">Gamelab</span> is an online game theory laboratory where participants assign mixed strategies
				to game bimatrices over a series of rounds, accumulating payoffs as the experiment progresses.
				The mission of <span class="nm">gamelab</span> is to allow for laboratory-style interaction without the
				need for a laboratory.
			</p>
			<p>
				This is the user's manual for <span class="nm">gamelab</span>.
				Its purpose is to <a href="#intro">introduce</a> the system, then describe how to <a href="#deploy">deploy</a>
				it and how to <a href="#administration">run experiments</a>.
			</p>
			<nav>
				<ul>
					<li>
						<a href="#intro">Introduction</a>
						<ul>
							<li><a href="#participants">Participants</a></li>
							<li><a href="#games">Games</a></li>
							<li><a href="#gameplay">Game-play</a></li>
							<li><a href="#lottery">Lottery</a></li>
						</ul>
					</li>
					<li>
						<a href="#technicalities">Technicalities</a>
						<ul>
							<li><a href="#userinterface">User Interface</a></li>
							<li><a href="#backend">Server Backend</a></li>
							<li><a href="#numformat">Number Format</a></li>
							<li><a href="#randomness">Randomness</a></li>
						</ul>
					</li>
					<li>
						<a href="#deploy">Deployment</a>
						<ul>
							<li><a href="#environment">Environment</a></li>
							<li><a href="#dependencies">Dependencies</a></li>
							<li><a href="#compiling">Compiling</a></li>
							<li><a href="#installation">Installation</a></li>
						</ul>
					</li>
					<li>
						<a href="#administration">Administration</a>
						<ul>
							<li><a href="#firstlogin">First Login</a></li>
							<li><a href="#firstexperiment">First Experiment</a></li>
							<li><a href="#runningexperiments">Running Experiments</a></li>
							<li><a href="#analysingexperiments">Analysing Experiments</a></li>
						</ul>
					</li>
					<li>
						<a href="#api">Programmable API</a>
						<ul>
							<li><a href="#generalseq">General Sequence</a></li>
							<li><a href="#resources">Resources</a></li>
							<li><a href="#objects">Objects</a></li>
						</ul>
					</li>
				</ul>
			</nav>
			<section id="intro">
				<h2>Introduction</h2>
				<p>
					<span class="nm">Gamelab</span> is an online laboratory for conducting game theory experiments.
					Experiments consist of an experimenter, an experiment configuration, participants, and a set of games.
					The web interface accomodates for desktop, mobile, and tablet-sized devices.
					You can even play experiments programatically over a JSON API.
				</p>
				<p>
					An experimenter begins by configuring how rounds in the experiment progress and for how long the
					experiment will run.
					Once the experimenter deploys the experiment, players can log in and play each game once per round.
					When the round advances, players earn points by computing the payoff from their submitted strategies
					against the average mixture submited by participants playing the opponent player role.
					After the last round, players' points award lottery tickets, and winners are drawn by selecting lottery
					tickets.
				</p>
				<section id="participants">
					<h3>Participants</h3>
					<p>
						Experiment participants are identified by an e-mail address, or in <q>captive</q> configurations
						(wherein participants register on-the-spot), by an opaque identifier.
						Your game can have as many participants as the server (or the experimenter!) can handle.
						In general, the more the merrier.
						You can even have participants join after the experiment has begun.
					</p>
					<p>
						Participants are assigned by the experimenter or assign themselves in a captive configuration:
						the experimenter chooses which (or a combination of both) during experiment preparation.
						In the former case, participants are e-mailed a password and login credentials when the
						experimenter begins the experiment.
						If assigned after the experiment has started, the experimenter must manually mail passwords.
						These participants can log in and log out over the course of the experiment.
						In the latter case, participants are not e-mailed, and are assumed to be <q>captive</q> for the
						duration of the experiment.
					</p>
					<p>
						When the experiment begins, participants are randomly assigned a player role per game.
						This defines whether the participant plays as the row or column player.
						Experiments always have an equal assignment of row and column players unless the total number of
						players is odd, in which case the extra player is assigned a random role.
						If participants join after the experiment has started, they are assigned to a player role that
						balances role counts at the time of assignment.
					</p>
				</section>
				<section id="games">
					<h3>Games</h3>
					<p>
						A game in <span class="nm">gamelab</span> is simply a payoff bi-matrix.
						There is no limit to the number of strategies for this matrix; however, in practise, only so
						many columns fit neatly on a small screen.
						Games larger than four or five strategies wide will look funny.
						Each experiment can have as many games as desired.
						Payoffs are rationally-valued numbers.
					</p>
				</section>
				<section id="gameplay">
					<h3>Game-play</h3>
					<p>
						Once the participant joins an experiment, participants can submit game-plays, one per game per
						round.
						A game-play consists of a strategy mixture: a set of probabilities assigned to each of the
						player role's actions.
						The submitted probabilities are non-negative and rationally-valued, and always sum to one.
						Participants submit these probabilites by clicking on rows in the game matrix (players appear to
						play the row player regardless of their player role) and entering in a decimal or rational
						number corresponding to the action.
					</p>
					<p>
						Participants can only play one game at a time, with each game played once per round.
						If they log out and log back in (an action available only to non-captive players), then the last game
						to play is displayed, assuming the round has not advanced in the meantime.
						Game matrices have their rows and columns randomly shuffled between participants, making it
						slightly more difficult to compare actions.
						Moreover, the order in which games are displayed is randomised between participants.
					</p>
					<p>
						At the conclusion of each round, players who have submitted mixtures for all games have their
						payoffs computed as points.
						(Rounds with incomplete games yield zero points.)
						Points are computed by playing the participant's mixture against the average mixture of
						participants in the opposing player role.
						Only opposing role participants who have played all games are considered.
						The points are then computed from the game payoffs.
						All of these calculations are over rational numbers and are unaffected by rounding.
						If not enough participants have played in a given player role, no points are tallied for the
						round.
					</p>
					<p>
						After the first round, participants can review the full history of play.
						This includes the history of their own strategy mixture, the average opponent role mixture, and
						the participant role's average mixture.
						Moreover, it includes the participant's accumulation of points, points per round, and the
						hypothetical points per round of playing pure strategies.
					</p>
				</section>
				<section id="lottery">
					<h3>Lottery</h3>
					<p>
						When a participant has exceeded her maximum allowed rounds, she is no longer able to submit
						plays to the experiment.
						When all rounds have concluded, the experiment halts.
						Participants may still log in and review the history, as well as see the total number of points
						awarded and their lottery ticket allotment.
					</p>
					<p>
						The experimenter may then trigger the lottery from the administration console.
						This consists of seeding a deterministic random number generator with a given value.
						Each of these values is mapped into the lottery tickets to choose a winner.
						A participant is only chosen once for winning: if the random number re-selects a participant,
						a new number is drawn (rejection sampling).
					</p>
					<p>
						Upon triggering winner selection, winner participants are notified on their login screen, along
						with the lottery ticket causing the win.
						This is for transparency of the winner selection.
						Non-winning participants are also notified.
					</p>
				</section>
			</section>
			<section id="technicalities">
				<h2>Technicalities</h2>
				<p>
					<span class="nm">Gamelab</span> uses a broad set of technologies to work.
					In this section, I briefly describe the specific technologies used.
					All of this is visible in the source code, but let this act as a primer.
					In general, these can be broken down into the user interface, which experimenters and participants use,
					and the server backend, which is accessed by the user interface.
				</p>
				<section id="userinterface">
					<h3>User Interface</h3>
					<p>
						The <q>user interface</q> to <span class="nm">gamelab</span> is via a web browser.
						In general, the user interface involves an HTML5 web-page styled with CSS.
						These web-page uses JavaScript to request data from the <span class="nm">gamelab</span> server
						via a series of JSON objects.
						The JavaScript used by <span class="nm">gamelab</span> is fairly recent, so it's unlikely that
						older browser will work properly.
						Check that your browser supports <code>ClassList</code> and <code>FormData</code>.
					</p>
					<p>
						The user interface also makes use of cookies to store your session materials.
						<span class="nm">Gamelab</span> cookies themselves don't store any identifiable material: they
						store only the server session identifier and a random number to prevent sharing of session
						identifiers.
					</p>
				</section>
				<section id="backend">
					<h3>Server Backend</h3>
					<p>
						The backend of <span class="nm">gamelab</span> is a <a href="http://learnbchs.org">BCHS</a>
						system consisting of two compiled CGI programs: one for the administrator, one for participants.
						These are small ISO C applications linking to <a
							href="http://kristaps.bsd.lv/kcgi">kcgi</a>, <a
							href="http://www.sqlite.org">sqlite3</a>, <a href="http://gmplib.org">GMP</a>, and <a
							href="http://curl.haxx.se/libcurl/">libCURL</a>.
						All of these are open source libraries.
						Consult the <a href="#deploy">Deployment</a> section for how to install these applications.
					</p>
				</section>
				<section id="numformat">
					<h3>Number Format</h3>
					<p>
						Internally, <span class="nm">gamelab</span> stores all non-integer numbers (strategy mixtures,
						payoffs, etc.) as rational numbers encoded as strings.
						These rational numbers are manipulated by <a href="http://gmplib.org">GMP</a> routines.
						The reason behind using rational numbers is precision: while the numbers themselves may grow
						quite large in size (if they compound), the library ensures that no roundoff occurs when
						tallying points.
					</p>
					<p>
						No floating-point numbers are used for internal tallies, although these are distributed to the
						web frontend for more intuitive representation.
					</p>
				</section>
				<section id="randomness">
					<h3>Randomness</h3>
					<p>
						Player section and group assignment, as well a other subsystems, require a reliable random
						number generator.
						To accomplish this, <span class="nm">gamelab</span> uses the BSD <a
							href="http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man3/arc4random.3">arc4random</a>
						system interface to provide high-quality randomness.
						This is emulated with <a href="https://wiki.freedesktop.org/libbsd/">libbsd</a> on GNU/Linux.
					</p>
					<p>
						<strong>Note</strong>: if you're running on GNU/Linux, you may not benefit from the high quality
						randomness, as well as the general security and reliability, of BSD systems.
						We strongly encourage BSD as a platform of choice, especially <a
							href="http://www.openbsd.org">OpenBSD</a>, which is the main development platform.
					</p>
				</section>
			</section>
			<section id="deploy">
				<h2>Deployment</h2>
				<p>
					<span class="nm">Gamelab</span> is a CGI application that runs under any CGI-compatible web server on a
					modern UNIX system.
					For now, you cannot run <span class="nm">gamelab</span> on a server that's not connected to the
					Internet: the icon set requires access to the <a href="https://fortawesome.github.io/Font-Awesome/">Font
						Awesome</a> online icon set.
					This will change with future releases to allow for <span class="nm">gamelab</span> deployments in VLAN
					and isolated computer environments.
				</p>
				<p>
					In order to use <span class="nm">gamelab</span>, you'll need to download, configure, and install
					it&mdash;just like any piece of software.
					<emph>Note</emph>: we're still getting <span class="nm">gamelab</span> into ship-shape, so the source
					can't yet be downloaded&#8211;contact us for a copy!
					If a system administrator has already installed the server and given you the web address for its
					laboratory and administrative interfaces, jump down to the <a href="#administration">Administration</a>
					section.
				</p>
				<p>
					If at any time you have problems during an installation, or you encounter confusing language, please
					e-mail <a href="mailto:kristaps@kcons.eu">Kristaps</a> with the issue.
				</p>
				<section id="environment">
					<h3>Environment</h3>
					<p>
						To operate a <span class="nm">gamelab</span> server, you'll need a modern UNIX system with a web
						server accessable to your participants.
						You are encouraged to use <a href="http://www.openbsd.org">OpenBSD</a>, which is the default
						testing and development environment.
						I don't discuss web server deployment in this manual: please consult your operating system
						documentation on how to do so.
						Specifically, you'll want to research on how to enable CGI scripts (<strong>not</strong>
						FastCGI).
					</p>
					<p>
						To date, <span class="nm">gamelab</span> has been deployed on Mac OS X, GNU/Linux, and a number
						of BSD systems.
						It has been run under the <a href="https://httpd.apache.org/">Apache</a> web server, 
						<a href="http://nginx.org/">nginx</a> via <a
							href="http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man8/slowcgi.8">slowcgi(8)</a>,
						and OpenBSD's <a
							href="http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man8/httpd.8">httpd(8)</a> via
						<a href="http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man8/slowcgi.8">slowcgi(8)</a>.
						The system is designed to run in a <q>jail</q> as is the default with OpenBSD <a
							href="http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man8/httpd.8">httpd(8)</a>.
						You are encouraged to do the same in any environment for security reasons; however, the system
						will also run fine in a non-jail context.
					</p>
					<p>
						Note that several newer web servers only work with FastCGI scripts.
						<span class="nm">Gamelab</span> does not run under FastCGI (yet), so you'll need to install the
						appropriate proxy for a CGI script.
					</p>
				</section>
				<section id="dependencies">
					<h3>Dependencies</h3>
					<p>
						With your environment prepared, you'll need to download the <span class="nm">gamelab</span>
						source code as well as its dependencies.
						These are <i>compile-time</i> dependencies, so if the system compiles, it will run just fine.
						There are no additional run-time dependencies.
						The dependencies consist of the following:
					</p>
					<ul>
						<li><a href="http://kristaps.bsd.lv">kcgi</a> (the CGI framework),</li>
						<li><a href="https://gmplib.org">GMP</a> (rational number library),</li>
						<li><a href="https://sqlite.org">SQLite</a> (database), and</li>
						<li><a href="http://libbsd.freedesktop.org/wiki/">libbsd</a> (Linux compatibility, if applicable),</li>
						<li><a href="http://curl.haxx.se/libcurl/">libCURL</a> (e-mailing), and</li>
						<li><a href="https://github.com/json-c/json-c/wiki">json-c</a> (testing system).</li>
					</ul>
					<p>
						The only external dependency required during operation is an Internet connection to use the <a
							href="https://fortawesome.github.io/Font-Awesome/">Font Awesome</a> icon set.
						This is expected to change over time.
					</p>
					<p>
						Each of these systems has its own installation procedure beyond the scope of this document.
						After you've installed the dependencies, download the source archive and the checksum.
					</p>
				</section>
				<section id="compiling">
					<h3>Compiling</h3>
					<p>
						Move the <span class="nm">gamelab</span> source code into a source directory (we suggest <span
							class="file">~/Source</span> or <span class="file">~/src</span> and unpack.
						First, however, verify the checksum.
						These instructions are valid for new installations and for upgrades: the source archive will
						unpack as <span class="file">gamelab-MAJOR-MINOR-BUILD</span>, so you won't overwrite previous
						installations on upgrading.
					</p>
					<p>
						<kbd>openssl dgst -sha512 gamelab.tgz | cmp - gamelab.tgz.sha512</kbd>
						<br />
						<kbd>tar zxf gamelab.tgz &amp;&amp; rm -f gamelab.tgz</kbd>
					</p>
					<p>
						Once you've unpacked the source code, you need to compile the server.
						Begin by editing the <span class="file">Makefile</span> to your specifications: these will
						hard-code a configuration that will define run-time operation, e.g., paths and filenames.
					</p>
					<dl>
						<dt><code>PREFIX</code></dt>
						<dd>
							Convenience variable for defining other variables.
							This is not used during operation.
						</dd>
						<dt id="htdocs"><code>HTDOCS</code></dt>
						<dd>
							This is a path used for installing read-only <q>static</q> pages, like CSS,
							JavaScript, and some HTML.
							This is usually the <q>htdocs</q> directory for your web server.
							In most web servers, this defaults to <span class="file">/var/www/htdocs</span>.
							It must be accessable (i.e., mapped) by the web server process.
						</dd>
						<dt><code>HTURI</code></dt>
						<dd>
							This is the URI location of the <a href="#htdocs"><code>HTDOCS</code></a> variable.
							In most web servers, this defaults to <span class="file">/</span> (the root).
						</dd>
						<dt id="cgibin"><code>CGIBIN</code></dt>
						<dd>
							This is the path used for installing compiled (executable) CGI binaries.
							This is usually the <q>cgibin</q> directory for your web server.
							In most web servers, this defaults to <span class="file">/var/www/cgi-bin</span>.
							It must be accessable (i.e., mapped) by the web server process.
						</dd>
						<dt id="adminuri"><code>ADMINURI</code></dt>
						<dd>
							This is the administrative CGI URI relative to the server root.
							It will correspond to the mapped location of <a href="#cgibin"><code>CGIBIN</code></a>
							plus the script name.
						</dd>
						<dt id="laburi"><code>LABURI</code></dt>
						<dd>
							This is the player (laboratory) CGI URI relative to the server root.
							It will correspond to the mapped location of <a href="#cgibin"><code>CGIBIN</code></a>
							plus the script name.
						</dd>
						<dt id="datadir"><code>DATADIR</code></dt>
						<dd>
							This is the path used for installing read-only data files.
							This doesn't have a standard location.
							We recommend using <span class="file">/var/www/data</span>.
							It <strong>must not</strong> be accessable by the web server process&mdash;only the
							running CGI processes.
						</dd>
						<dt><code>RDATADIR</code></dt>
						<dd>
							This is the path used by the running CGI process to find <a
								href="#datadir"><code>DATADIR</code></a>.
							This is because the running process may be jailed in a file-system (such as <span
								class="file">/var/www</span>) and the absolute path of <a
								href="#datadir"><code>DATADIR</code></a> may not be available.
						</dd>
						<dt><code>LIBS</code></dt>
						<dd>
							If you're going to statically link (see <a href="#static"><code>STATIC</code></a>) then
							you may need to define extra libraries to satisfy your compiler.
							This really depends on the operating system.
							For OpenBSD, you'll need to define <code>-lintl -liconv</code>.
							For non-static compilations, you probably don't need anything here.
						</dd>
						<dt id="static"><code>STATIC</code></dt>
						<dd>
							If you're going to run in a file-system jail and don't want to import dynamic libraries,
							you can statically compile the <span class="nm">gamelab</span> executable by specifying
							<code>-static</code>.
						</dd>
					</dl>
					<p>
						Sample variables are set for a local Mac OS X installation (non-static in one's <span
							class="file">~/Sites</span> directory) and OpenBSD production (static in a named
						subdirectory of the usual installation locations).
					</p>
					<p>
						Once you've defined these variables, compile the software in the usual way by executing
						<kbd>make</kbd>.
					</p>
				</section>
				<section id="installation">
					<h3>Installation</h3>
					<p>
						Once you've <a href="#compiling">compiled</a> the software and configured its parameters, you
						can install it by simply running <kbd>make install</kbd>.
						You'll probably need to do <kbd>sudo make install</kbd>, however.
					</p>
					<p>
						<strong>Warning</strong>: this will overwrite any existing database!
						To update an existing installation (assuming the database hasn't changed&mdash;the release notes
						for each version will tell you), use <kbd>make update</kbd> or <kbd>sudo make update</kbd>.
						I <strong>do not</strong> recommend this, as it's easy to miss a small database change.
					</p>
					<p>
						Both of these steps will install the following.
					</p>
					<dl>
						<dt><span class="file">admin</span></dt>
						<dt><span class="file">admin.cgi</span></dt>
						<dd>
							The administrative CGI executable installed into <a
								href="#cgibin"><code>CGIBIN</code></a>.
							These files are identical but for the suffix.
							These must resolve to <a href="#adminuri"><code>ADMINURI</code></a>.
						</dd>
						<dt><span class="file">lab</span></dt>
						<dt><span class="file">lab.cgi</span></dt>
						<dd>
							The laboratory CGI executable installed into <a href="#cgibin"><code>CGIBIN</code></a>.
							These files are identical but for the suffix.
							These must resolve to <a href="#laburi"><code>LABURI</code></a>.
						</dd>
						<dt><span class="file">adminhome.css</span></dt>
						<dt><span class="file">adminhome.js</span></dt>
						<dt><span class="file">adminlogin.html</span></dt>
						<dt><span class="file">playerautoadd.html</span></dt>
						<dt><span class="file">playerhome.css</span></dt>
						<dt><span class="file">playerhome.js</span></dt>
						<dt><span class="file">playerhome.html</span></dt>
						<dt><span class="file">playerlobby.css</span></dt>
						<dt><span class="file">playerlobby.html</span></dt>
						<dt><span class="file">playerlogin.html</span></dt>
						<dt><span class="file">privacy.html</span></dt>
						<dt><span class="file">style.css</span></dt>
						<dt><span class="file">script.js</span></dt>
						<dd>
							These statically-served, read-only files are installed into <a
								href="#htdocs"><code>HTDOCS</code></a>.
						</dd>
						<dt><span class="file">addplayer.eml</span></dt>
						<dt><span class="file">adminhome-new.html</span></dt>
						<dt><span class="file">adminhome-started.html</span></dt>
						<dt><span class="file">backupfail.eml</span></dt>
						<dt><span class="file">backupsuccess.eml</span></dt>
						<dt><span class="file">test.eml</span></dt>
						<dd>
							These read-only files are installed into <a href="#datadir"><code>DATADIR</code></a>.
							They are used by the CGI processes to serve content to data requests.
						</dd>
					</dl>
					<p>
						If you run <kbd>make install</kbd> (instead of <kbd>make update</kbd>), the following will also
						be installed.
					</p>
					<dl>
						<dt><span class="file">gamelab.db</span></dt>
						<dd>
							The writable database file itself, installed into <a
								href="#datadir"><code>DATADIR</code></a>.
							This is initialised to the defaults described in the <a
								href="#administration">Administration</a> section.
						</dd>
					</dl>
					<p>
						<strong>Note</strong>: the SQLite database system usually needs access to a <a
							href="https://www.sqlite.org/c3ref/temp_directory.html">temporary directory</a> for
						journalling (it uses <a href="https://www.sqlite.org/wal.html">write-ahead logging</a>) and so
						forth.
						If you're running in a file-system jail (e.g., OpenBSD), you'll need to make sure this
						directory exists in the root of the jai.
						On default installations, this consists of a <span class="file">tmp</span> directory in the
						document root, e.g., <span class="file">/var/www/tmp</span>, with world-writable permissions.
					</p>
					<p>
						<strong>Note</strong>: if you're running in a file-system jail, the security measures of <a
							href="http://kristaps.bsd.lv/kcgi">kcgi</a> on OpenBSD (or any <a
							href="http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man4/systrace.4">systrace(4)</a>
						system) require a systrace device in the <span class="file">dev</span> directory of the document
						root, e.g., <span class="file">/var/www/dev</span>.
						Moreover, the file-system of this directory must not be <code>nodev</code> in its mount options
						(see <a
							href="http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man8/mount.8">mount(8)</a>).
					</p>
					<p>
						Once you've deployed your system, you can test it by going to the administration site.
					</p>
				</section>
			</section>
			<section id="administration">
				<h2>Administration</h2>
				<p>
					In this section, I describe how to administer the <span class="nm">gamelab</span> system.
					I assume that you've just installed it following the <a href="#installation">Installation</a> section or
					that your system administrator has done so.
					I'll use screenshots from the <a class="http://getfirefox.org">Firefox</a> web browser installed on Mac
					OS X.  Your system may not look like this&mdash;that's ok.
				</p>
				<p>
					<span class="nm">Gamelab</span> experiments consist of a series of games (normal form bimatrices) played
					by a set of participants over a finite number of rounds of a certain amount of time.
					When the experiment is over, you run a lottery that selects a participant as a winner of the experiment.
					Thus, to run an experiment, you'll need players, games, and a duration of time split into rounds.
				</p>
				<p>
					You can only run one experiment at a time on each <span class="nm">gamelab</span> installation.
					However, you can back up and wipe the experiment installation database&mdash;starting over&mdash;at any
					time to start over.
				</p>
				<section id="firstlogin">
					<h3>First Login</h3>
					<p>
						Begin by accessing the administrator URL with your browser.
						This will usually look like <span class="url">http://foo.com/cgi-bin/admin</span>, but it
						depends on how your system administrator has configured the system.
						You will be taken to a page prompting for an e-mail and password.
						<strong>Note</strong>: you'll need to configure your browser to accept cookies and run
						JavaScript for the domain upon which <span class="nm">gamelab</span> is running.
					</p>
					<figure>
						<a href="screen-admin1.png"><img src="screen-admin1.png" alt="Administrator Login" /></a>
					</figure>
					<p>
						The default e-mail address is <samp>foo@example.com</samp> and the default password is
						<samp>foobar</samp>.
						If the system has been properly configured, you'll be logged in.
						<strong>Note</strong>: you can log out at any time by clicking the navigation bars in the upper
						left-hand corner, then selecting <q>Logout</q>.
					</p>
					<p>
						The first thing you should do upon logging in is change the administrator e-mail address and password.
						Set the administrator e-mail to be your own e-mail address and the password to something fairly
						complicated.
						You'll be logged out&mdash;and must log back in&mdash;after each step.
						Make sure that no participants will be able to guess (or know) your credentials!
					</p>
					<figure>
						<a href="screen-admin2.png"><img src="screen-admin2.png" alt="Administrator Homepage" /></a>
					</figure>
					<p>
						The next step is e-mail configuration.
						<span class="nm">Gamelab</span> uses e-mail to notify participants of events.
						You won't be able to use the system properly without it!
						You may need your system administrator's help, but you should be able to enter the same information as
						when you configure your e-mail reader: 
						the <q>from</q> address the e-mails will use (usually your own so that they can respond to you);
						the outgoing (SMTP) e-mail server in the form <samp>smtp://foo.bar:587</samp>; 
						and the user and password for accessing that server.
						<span class="nm">Gamelab</span> won't work for non-secure (i.e., non-TLS) e-mail access.
					</p>
					<figure>
						<a href="screen-admin3.png"><img src="screen-admin3.png" alt="Administrator Homepage" /></a>
					</figure>
					<p>
						When you're finished entering this information, test the configuration.
						You should receive an e-mail in a few minutes from the <span class="nm">gamelab</span> server.
					</p>
				</section>
				<section id="firstexperiment">
					<h3>First Experiment</h3>
					<p>
						Now that you've set your e-mail and administrator credentials as described in <a
							href="#firstlogin">First Login</a>, you're ready to configure an experiment.
						Don't worry&mdash;you don't need to start your experiment immediately.
						You can slowly add the players and games you want until you're ready to deploy the experiment
						itself.
						Start with the following.
					</p>
					<figure>
						<a href="screen-admin4.png"><img src="screen-admin4.png" alt="Administrator Homepage" /></a>
					</figure>
					<ul>
						<li>
							A set of players identified by e-mail address.
							The more, the merrier, but you'll need two at a minimum.
							(If you're running with captive players, at least two will need to have registered.)
							Make sure the e-mail addresses are real!
							Enter these e-mails into the <q>Players</q> section.
							You'll be able to add and remove e-mails before the experiment, so no worries.
							Moreover, if you start an experiment with mistaken e-mails, you'll be able to disable them.
							If you specify <q>Allow captive players</q>, participants can register themselves by
							accessing the <span class="file">playerautoadd.html</span> URL.
							They are captive in the sense that their logout button is disabled and that they are
							<strong>never</strong> e-mailed, nor are they retained if the database is wiped.
							They will be shown with a special symbol.
							In general, captive mode is disabled when you start an experiment.
							This is a security measure so that players can't join after you've started.
							You can opt to allow players to continually join by specifying that captive mode should
							be preserved when the experiment begins.
						</li>
						<li>
							A set of normal form bimatrix games.
							These can have any number of strategies and either positive integer or rational payoffs.
							Enter these games into the <q>Games</q> section.
							Bimatrix games are laid out top-left to bottom-right.
							So let's say you have the following game shown first as a symmetric game then with the
							<span style="color: red;">implied payoffs</span> to the opponent player.
							<div id="gamepanes" class="gamepanes"><div>
									<table>
										<tr>
											<td>1</td>
											<td>0</td>
											<td>-1</td>
										</tr>
										<tr>
											<td>0</td>
											<td>-1</td>
											<td>1</td>
										</tr>
										<tr>
											<td>-1</td>
											<td>1</td>
											<td>0</td>
										</tr>
									</table>
								</div><div>
									<table>
										<tr>
											<td>1<span>, -1</span></td>
											<td>0<span>, 0</span></td>
											<td>-1<span>, 1</span></td>
										</tr>
										<tr>
											<td>0<span>, 0</span></td>
											<td>-1<span>, 1</span></td>
											<td>1<span>, -1</span></td>
										</tr>
										<tr>
											<td>-1<span>, 1</span></td>
											<td>1<span>, -1</span></td>
											<td>0<span>, 0</span></td>
										</tr>
									</table>
							</div></div>
							These would decompose into <kbd class="gamepayoffs">1 <span>-1</span> 0 <span>0</span>
								-1 <span>1</span> 0 <span>0</span> -1 <span>1</span> 1 <span>-1</span> -1
								<span>1</span> 1 <span>-1</span> 0 <span>0</span></kbd>,
							where opponent payoffs are <span style="color: red;">coloured</span>.
						</li>
						<li>
							The duration (minutes per round and rounds) that players will participate in the
							experiment.
							The round time is specified in minutes.
							It's important to factor in network lag: while one-minute experiments are certainly
							well-tested and possible, they're not realistic if people sometimes must wait for the
							page to load!
						</li>
					</ul>
					<figure>
						<a href="screen-admin5.png"><img src="screen-admin5.png" alt="Administrator Homepage" /></a>
					</figure>
					<p>
						Once you've added your games and your players, you're ready to actually deploy the experiment
						itself.
						Set the time and date when the experiment begins (<strong>remember</strong>: in GMT!) and the
						number of rounds and duration of each round.
						If you enter a non-zero percentage for the number of players per role, then the round will
						advance if enough players have played.
						For example, if set to 50%, then 50% or more players playing all games in both roles will cause
						the round to advance regardless the amount of time left.
						(If not enough players play, then round will advance by the given, and now maximum, time.)
						For non-zero percentages, you can also specify a <q>grace time</q> in minutes: the experiment
						won't automatically advance rounds until after this duration.
						<!-- If there are no players to play (for example, when allowing players to dynamically join after
						starting for fewer plays than total rounds), the round will advance immediately after any grace
						time. -->
					</p>
					<p>
						You can edit the instructions given to players&mdash;in fact, that's a good idea, as you
						probably want to tune the winnings.
						Then hit <q>Start</q> and you're ready to go!
					</p>
					<p>
						Once you hit the <q>Start</q> button, the experiment has begun.
						It won't be playable until the time and date you specified, but the players are notified
						immediately with their login credentials.
						Only players you add are e-mailed: captive players are not e-mailed.
					</p>
				</section>
				<section id="runningexperiments">
					<h3>Running Experiments</h3>
					<p>
						Once you've deployed your experiment as described in <a href="#firstexperiment">First
							Experiment</a>, you must now administer it.
						For the time being, there's very little in the way of <span class="nm">gamelab</span>
						administration.
						You can enable and disable players, reset player passwords, and reconfigure your administrator
						credentials.
					</p>
					<figure>
						<a href="screen-admin7.png"><img src="screen-admin7.png" alt="Administrator Homepage" /></a>
					</figure>
					<p>
						If a player forgets her password, you can reset it by clicking on the player's email address and
						selecting the <q>Reset Password</q> option.
						(Auto-added players are <strong>not</strong> affected.)
						You can reset all non-captive players' passwords with the <q>Reset All Passwords</q> option.
						If a player is misbehaving, you can disable her login by toggling the button next to her e-mail
						address.
						Once toggled, she'll no longer be able to log in.
						If she's already logged in, she'll be logged out; no plays are accepted.
					</p>
					<p>
						If you misconfigured the e-mail server and no e-mails were sent out, you can retry the failed
						e-mail attempts by re-configuring (correctly!) the server and selecting <q>Resend Error
							Mails</q>.
					</p>
					<p>
						When a game has finished, you can compute its lottery by specifying a seed for the random number
						generator and a number of lottery winners.
						<strong>Note</strong>: for the time being, only choose one!
					</p>
					<figure>
						<a href="screen-admin6.png"><img src="screen-admin6.png" alt="Administrator Homepage" /></a>
					</figure>
					<p>
						Once the winner has been chosen and notified, and the game wound down, you can wipe and start
						afresh by selecting the <q>Wipe Experiment</q> option.
						This will first back up the database (e-mailing it to you in the process), then wipe all by the
						administrator credentials, listed games, and player identities (though not their play, of
						course).
						Note that captive players are not retained if the database is wiped.
					</p>
				</section>
				<section id="analysingexperiments">
					<h3>Analysing Experiments</h3>
					<p>
						At this time, <span class="nm">gamelab</span> doesn't have any special functionality for
						analysing played (or in-flight) experiments.
						You can, however, directly access the <a href="http://sqlite.org">SQLite</a> game database by
						backing up on the administrative console.
						This will e-mail a redacted database to the administrator.
						The redacted bits consist of user and administrator e-mail passwords.
					</p>
					<p>
						The database schema is fairly straightforward.
						It consists of the following tables.
						In all of these, note that <q>Unique Identifier</q> fields are non-zero SQLite <q>rowid</q> fields.
						Rational numbers are stored as text, such as <var>1/2</var> or just <var>2</var>, starting with
						<var>0/1</var>.
					</p>
					<dl>
						<dt id="db-winner"><code>winner</code></dt>
						<dd>
							<p>
								The <code>winner</code> table consists of rows corresponding to a player and her
								winner status.
								This table does not exist until the <a
									href="db-experiment-status"><var>status</var></a> field of the <a
									href="#db-experiment"><code>experiment</code></a> is set to
								<var>3</var>.
								This table is deleted when the database is wiped.
							</p>
							<dl>
								<dt id="db-winner-playerid"><var>playerid</var></dt>
								<dd>A foreign key reference to the <a href="#db-player"><code>player</code></a> table.</dd>
								<dt id="db-winner-winner"><var>winner</var></dt>
								<dd>
									Boolean value as to whether the player is a winner.
									If this is <var>false</var>, then the <a
										href="#db-winner-winrank"><var>winrank</var></a> and
									<a href="#db-winner-rnum"><var>rnum</var></a> columns are undefined.
								</dd>
								<dt id="db-winner-winrank"><var>winrank</var></dt>
								<dd>If the player is a winner, the rank (first, second, third draw...) of their winning.</dd>
								<dt id="db-winner-rnum"><var>rnum</var></dt>
								<dd>
									The random number modulo the total number of tickts used for this winning draw.
									In other words, this is the winning lottery ticket.
								</dd>
								<dt id="db-winner-id"><var>id</var></dt>
								<dd>Unique identifier.</dd>
							</dl>
						</dd>
						<dt id="db-player"><code>player</code></dt>
						<dd>
							<p>
								The central <code>player</code> table consists of all participants.
								The <a href="#db-player-hash"><var>hash</var></a> variable is redacted when the
								experiment is wiped.
							</p>
							<dl>
								<dt id="db-player-answer"><var>answer</var></dt>
								<dd>
									If the questionnaire facility has been enabled (via the <a
										href="#db-experiment"><code>experiment</code></a> <a
										href="#db-experiment-questionnaire"><var>questionnaire</var></a>),
									this is non-zero if the questionnaire has been answered.
								</dd>
								<dt id="db-player-autoadd"><var>autoadd</var></dt>
								<dd>
									Player was auto-added (i.e., auto-added herself).
									These players are never e-mailed.
								</dd>
								<dt id="db-player-email"><var>email</var></dt>
								<dd>Player e-mail address.  This is unique in the set of all players.</dd>
								<dt id="db-player-state"><var>state</var></dt>
								<dd>
									The state of a player can be <var>0</var>, meaning the player is
									newly-added and has no password; <var>1</var> when the player has been
									mailed her password; <var>2</var>, the player has logged in; and
									<var>3</var>, an error occured when the password e-mail was attempted.
								</dd>
								<dt id="db-player-enabled"><var>enabled</var></dt>
								<dd>Whether a player is allowed to login during an experiment.</dd>
								<dt id="db-player-rseed"><var>rseed</var></dt>
								<dd>A non-zero cryptographically random number given to the player when created.</dd>
								<dt id="db-player-role"><var>role</var></dt>
								<dd>The player role (<var>0</var> for row player, <var>1</var> for column
									player) set when the <a
										href="#db-experiment"><code>experiment</code></a> <a
										href="#db-experiment-state"><var>state</var></a> is
									&gt;0.</dd>
								<dt id="db-player-instr"><var>instr</var></dt>
								<dd>Whether the player should be shown instructions when she logs in (versus
									being taken directly to the game-play tab).</dd>
								<dt id="db-player-finalrank"><var>finalrank</var></dt>
								<dd>The minimum of the slot of the player's tickets among all players' tickets.
									For example, given 100 players with roughly 10 tickets each, this might
									be <var>543</var> to indicate that slot <var>543</var> to <var>543</var>
									plus <a href="#db-player-finalscore"><var>finalscore</var></a> are this
									player's slots in the lottery.</dd>
								<dt id="db-player-finalscore"><var>finalscore</var></dt>
								<dd>Set to the accumulated payoffs from the <a
										href="#db-lottery"><code>lottery</code></a> <a
										href="#db-lottery-aggrpayoff"><var>aggrpayoff</var></a>
									rounded up to the nearest integer.</dd>
								<dt id="db-player-hash"><var>hash</var></dt>
								<dd>The player's password set when the experiment is started (i.e., when the <a
										href="#db-experiment"><code>experiment</code></a> <a
										href="#db-experiment-state"><var>state</var></a> is &gt;0) or
									when reset. <strong>Note</strong>: this is stored in the clear: it is
									not (yet) a hash.</dd>
								<dt id="db-player-id"><var>id</var></dt>
								<dd>Unique identifier.</dd>
								<dt id="db-player-version"><var>version</var></dt>
								<dd>
									A number from zero that indicates the number of time the player field
									has been updated.
									This is used to make the player object cachable.
								</dd>
							</dl>
						</dd>
						<dt id="db-lottery"><code>lottery</code></dt>
						<dd>
							<p>
								A lottery is created for an individual <a
									href="#db-player"><code>player</code></a> when that player has been
								granted <a href="#db-payoff"><code>payoff</code></a> for all <a
									href="#db-game"><code>game</code></a> rows in a round.
							</p>
							<dl>
								<dt id="db-lottery-aggrpayoff"><var>aggrpayoff</var></dt>
								<dd>
									The player's aggregate payoff (as a rational number) computing by adding
									the previous round's aggregate payoff to the current <a
										href="#db-lottery-curpayoff"><var>curpayoff</var></a>.
								</dd>
								<dt id="db-lottery-aggrtickets"><var>aggrtickets</var></dt>
								<dd>
									The value of <a href="#db-lottery-aggrpayoff"><var>aggrpayoff</var></a>
									represented as a natural number of tickets.
								</dd>
								<dt id="db-lottery-curpayoff"><var>curpayoff</var></dt>
								<dd>The player's current payoff (as a rational number) computing by accumulating
									her <a href="#db-payoff"><code>payoff</code></a> <a
										href="#db-payoff-payoff"><var>payoff</var></a> for all
									games in the experiment.
									This is set to <var>0/1</var> if the player has not played all
									games.</dd>
								<dt id="db-lottery-id"><var>id</var></dt>
								<dd>Unique identifier.</dd>
								<dt id="db-lottery-playerid"><var>playerid</var></dt>
								<dd>A foreign key reference to the <a href="#db-player"><code>player</code></a>
									<a href="#db-player-id"><var>id</var></a>.</dd>
								<dt id="db-lottery-round"><var>round</var></dt>
								<dd>The round number (starting at zero).</dd>
							</dl>
						</dd>
						<dt id="db-gameplay"><code>gameplay</code></dt>
						<dd>
							<p>
								During a given round, this records a <a
									href="#db-player"><code>player</code></a>'s status in terms of number of
								<a href="#db-choice"><code>choice</code></a> rows (plays) made.
							</p>
							<dl>
								<dt id="db-gameplay-round"><var>round</var></dt>
								<dd>The round number (starting at zero).</dd>
								<dt id="db-gameplay-choices"><var>choices</var></dt>
								<dd>The number of games this player has played, i.e., the count of <a
										href="#db-choice"><code>choice</code></a> rows.</dd>
								<dt id="db-gameplay-playerid"><var>playerid</var></dt>
								<dd>A foreign key reference to the <a href="#db-player"><code>player</code></a>
									<a href="#db-player-id"><var>id</var></a>. When this equals the number
									of games, the player has played all games for a round.</dd>
								<dt id="db-gameplay-id"><var>id</var></dt>
								<dd>Unique identifier.</dd>
							</dl>
						</dd>
						<dt id="db-payoff"><code>payoff</code></dt>
						<dd>
							<p>
								When the given round has completed, this consists of the payoff of the player's
								<a href="#db-choice"><code>choice</code></a> strategy mix for a given <a
									href="#db-game"><code>game</code></a> when played against the average
								strategy of the opposing player role.
							</p>
							<dl>
								<dt id="db-payoff-round"><var>round</var></dt>
								<dd>The round number (starting at zero).</dd>
								<dt id="db-payoff-playerid"><var>playerid</var></dt>
								<dd>A foreign key reference to the <a href="#db-player"><code>player</code></a>
									<a href="#db-player-id"><var>id</var></a>. When this equals the number
									of games, the player has played all games for a round.</dd>
								<dt id="db-payoff-gameid"><var>gameid</var></dt>
								<dd>A foreign key reference to the <a href="#db-game"><code>game</code></a>
									<a href="#db-game-id"><var>id</var></a>.</dd>
								<dt id="db-payoff-payoff"><var>payoff</var></dt>
								<dd>A rational number of the payoff.</dd>
								<dt id="db-payoff-id"><var>id</var></dt>
								<dd>Unique identifier.</dd>
							</dl>
						</dd>
						<dt id="db-choice"><code>choice</code></dt>
						<dd>
							<p>
								A strategy mixture created when a <a href="#db-player"><code>player</code></a>
								plays a round in a <a href="#db-game"><code>game</code></a>.
							</p>
							<dl>
								<dt id="db-choice-round"><var>round</var></dt>
								<dd>
									The round number (starting at zero).
								</dd>
								<dt id="db-choice-sessid"><var>sessid</var></dt>
								<dd>
									The <a href="#db-sess"><code>sess</code></a> used when submitting this choice mixture.
								</dd>
								<dt id="db-choice-created"><var>created</var></dt>
								<dd>
									The epoch timestamp when this choice was made.
								</dd>
								<dt id="db-choice-strats"><var>strats</var></dt>
								<dd>
									A text (space-separated) list of rational numbers of the strategy mixture
									ordered from the top if a row-playing <a
										href="#db-player-role"><var>role</var></a> or left if a
									column-player.
								</dd>
								<dt id="db-choice-stratsz"><var>stratsz</var></dt>
								<dd>
									Number of entries in <a href="#db-choice-strats"><var>strats</var></a>.
									This obviously equals the number of strategies available to the player
									in that <a href="#db-game"><code>game</code></a>, given the player <a
										href="#db-player-role"><var>role</var></a>.
								</dd>
								<dt id="db-choice-playerid"><var>playerid</var></dt>
								<dd>
									A foreign key reference to the <a href="#db-player"><code>player</code></a>
									<a href="#db-player-id"><var>id</var></a>.
								</dd>
								<dt id="db-choice-gameid"><var>gameid</var></dt>
								<dd>
									A foreign key reference to the <a href="#db-game"><code>game</code></a>
									<a href="#db-game-id"><var>id</var></a>.
								</dd>
								<dt id="db-choice-id"><var>id</var></dt>
								<dd>Unique identifier.</dd>
							</dl>
						</dd>
						<dt id="db-experiment"><code>experiment</code></dt>
						<dd>
							<p>
								This describes an experiment configured by the experimenter.
								There is always one (and only one) row in this table.
								It is initialised to default values.
							</p>
							<dl>
								<dt id="db-experiment-autoadd"><var>autoadd</var></dt>
								<dd>The experiment is currently accepting (or did accept) auto-added players.</dd>
								<dt id="db-experiment-autoaddpreserve"><var>autoaddpreserve</var></dt>
								<dd>
									Preserve the <a href="#db-experiment-autoadd"><var>autoadd</var></a> bit
									during and after the experiment start.
									This is useful for rolling experiments so as not to have a break between
									starting the experiment and reenabling captive mode.
								</dd>
								<dt id="db-experiment-end"><var>end</var></dt>
								<dd>An epoch-encoded (seconds) time and date when the experiment when the last
									round of the experiment concludes.  This also corresponds to the
									starting time plus the number of rounds times round duration.</dd>
								<dt id="db-experiment-id"><var>id</var></dt>
								<dd>Unique identifier.</dd>
								<dt id="db-experiment-instr"><var>instr</var></dt>
								<dd>The instructions shown to players.  This must contain valid HTML5.  It may
									contain <code>@@gamelab-admin-email@@</code>, which is filled in with
									the experimenter's configured e-mail address;
									<code>@@gamelab-games@@</code> for the number of games;
									<code>@@gamelab-rounds@@</code> for the number of rounds; and
									<code>@@gamelab-round-time@@</code>, a decimal number of the number of
									hours per round.</dd>
								<dt id="db-experiment-loginuri"><var>loginuri</var></dt>
								<dd>Set when the experiment begins (i.e., when <a
										href="#db-experiment-state"><var>state</var></a> &gt;0), this is
									the URL given to players in their initial e-mail for when they log in.
									This is suffixed by
									<code>?ident=EMAIL&amp;password=PASSWORD</code>.</dd>
								<dt id="db-experiment-minutes"><var>minutes</var></dt>
								<dd>The number of minutes per round.  Minimum of one.</dd>
								<dt id="db-experiment-nolottery"><var>nolottery</var></dt>
								<dd>
									If non-zero, do not show the lottery facility to players or the
									administrator.
								</dd>
								<dt id="db-experiment-playermax"><var>playermax</var></dt>
								<dd>
									The maximum number of players per player role at any given time.
									If zero, the number of players is unbound.
								</dd>
								<dt id="db-experiment-prounds"><var>prounds</var></dt>
								<dd>
									The number of rounds playable by each player.
									If zero, players will play until the end of the experiment.
									If &gt;0, players will not be allowed to play more than the given number
									of rounds within the experiment.
								</dd>
								<dt id="db-experiment-questionnaire"><var>questionnaire</var></dt>
								<dd>
									If non-zero, new players are not directly assigned a join round and must
									use the lobby facility.
									There, they will be asked questions and cannot proceed until all
									questions have been answered.
								</dd>
								<dt id="db-experiment-round"><var>round</var></dt>
								<dd>
									The current round of the experiment, or -1 if the rounds have not begun incrementing.
									This will be set to <a
										href="#db-experiment-rounds"><var>rounds</var></a> when the
									experiment concludes.
								</dd>
								<dt id="db-experiment-roundbegan"><var>roundbegan</var></dt>
								<dd>
									If <a href="#db-experiment-round"><var>round</var></a> is non-negative,
									then the timestamp (epoch) when the round was incremented.
									Otherwise, this is zero.
								</dd>
								<dt id="db-experiment-roundmin"><var>roundmin</var></dt>
								<dd>
									If <a href="#db-experiment-roundpct"><var>roundpct</var></a> is
									non-zero, this is the <q>grace time</q> (in minutes) before which the
									round will automatically advance giving the percentage.
								</dd>
								<dt id="db-experiment-roundpct"><var>roundpct</var></dt>
								<dd>
									If &gt;0, this represents the fraction of players per role who play all
									games and determine that the round automatically advances.
									In other words, if set to 0.5 (50%), then from both player roles, if 50%
									or more players have played all games, the round advances in advance of
									the set round termination time.
								</dd>
								<dt id="db-experiment-rounds"><var>rounds</var></dt>
								<dd>The number of rounds that will be played.  Minimum of one.</dd>
								<dt id="db-experiment-start"><var>start</var></dt>
								<dd>An epoch-encoded (seconds) time and date when the experiment when the first
									round of the experiment begins.</dd>
								<dt id="db-experiment-state"><var>state</var></dt>
								<dd>The running state of the experiment, being either <var>0</var>, for new
									(still in the configuration stage); <var>1</var>, for started (players
									can log in, though the experiment itself may not be accepting plays
									yet); <var>2</var>, where the experiment has expired, but the winner has
									not been chosen by the experimenter; or <var>3</var>, where the
									experiment has expired and the winner has been chosen.</dd>
								<dt id="db-experiment-total"><var>total</var></dt>
								<dd>When the experiment finishes (i.e., when <a
										href="#db-experiment-state"><var>state</var></a> is set to 2),
									this is filled in with the total number of lottery tickets (the <a
										href="#db-player-finalscore"><var>finalscore</var></a>) awarded to
									all players.</dd>
							</dl>
						</dd>
						<dt id="db-game"><code>game</code></dt>
						<dd>
							<p>
								A game is a payoff bimatrix configured by the experimenter.
								There may be any non-zero number of games in a running experiment.
							</p>
							<dl>
								<dt id="db-game-p1"><var>p1</var></dt>
								<dd>The number of strategies for the row player.</dd>
								<dt id="db-game-p2"><var>p2</var></dt>
								<dd>The number of strategies for the column player.</dd>
								<dt id="db-game-payoffs"><var>payoffs</var></dt>
								<dd>A list of payoffs from the top-left to the bottom-right of the payoff
									matrix, ordered row-player payoff, column-player payoff.
									See <a href="#firstexperiment">First Experiment</a> configuration for
									more.</dd>
								<dt id="db-game-name"><var>name</var></dt>
								<dd>The name of the experiment.  This is shown only to the experimenter.</dd>
								<dt id="db-game-id"><var>id</var></dt>
								<dd>Unique identifier.</dd>
							</dl>
						</dd>
						<dt id="db-sess"><code>sess</code></dt>
						<dd>
							<p>
								A session.
								Sessions are the usual browser session used when players (or the experimenter)
								are interacting with the system.
							</p>
							<dl>
								<dt id="db-sess-created"><var>created</var></dt>
								<dd>
									An epoch timestamp of when the session was originally created.
								</dd>
								<dt id="db-sess-cookie"><var>cookie</var></dt>
								<dd>
									A cryptographically random cookie assigned to each session.
									This is used as a security feature so that people can't guess others'
									session identifiers and re-use them.
									When a session has expired or the user is logged out, this is set to
									zero.
									(Session entries are never deleted.)
								</dd>
								<dt id="db-sess-playerid"><var>playerid</var></dt>
								<dd>
									A foreign key reference to the <a
										href="#db-player"><code>player</code></a> <a
										href="#db-player-id"><var>id</var></a>.
									For experimenter logins, this value is <var>null</var>.
								</dd>
								<dt id="db-sess-useragent"><var>useragent</var></dt>
								<dd>
									The user-agent as reported by the player's (or administrator's) browser.
									Remember: these are easy to fake, so they shouldn't be taken as
									authoritative, but suggestive.
									Also note that this is set when the player first creates the session
									(cookie), and may not reflect later plays.
									(But usually does.)
								</dd>
								<dt id="db-sess-id"><var>id</var></dt>
								<dd>Unique identifier.</dd>
							</dl>
						</dd>
						<dt id="db-admin"><code>admin</code></dt>
						<dd>
							<p>
								Administrator (a.k.a. experimenter) credentials.
								There is always one (and only one) row that exists, initialised to default
								values.
							</p>
							<dl>
								<dt id="db-admin-email"><var>email</var></dt>
								<dd>The experimenter e-mail address.  This is used as a predefined template
									value for the instructions.  It is also used as the destination for
									backups of the database.  Initialises to <code>foo@example.com</code>.</dd>
								<dt id="db-admin-hash"><var>hash</var></dt>
								<dd>The experimenter password.  <strong>Note</strong>: this is stored as
									cleartext, so it is not really a hash (yet).  Initialises to
									<code>xyzzy</code>.</dd>
								<dt id="db-admin-isset"><var>isset</var></dt>
								<dd>
									Bit-field on whether the email and hash have been set by the user.
									Contains 0x01 if the e-mail has been set, 0x02 for the password.
								</dd>
								<dt id="db-admin-id"><var>id</var></dt>
								<dd>Unique identifier.</dd>
							</dl>
						</dd>
						<dt id="db-past"><code>past</code></dt>
						<dd>
							<p>
								Records the average strategy mixture of a given player role for a given round
								and <a href="#db-game"><code>game</code></a> when a round has concluded.
							</p>
							<dl>
								<dt id="db-past-averagesp1"><var>averagesp1</var></dt>
								<dd>
									For the row player, the accumulated weighted average strategy mixture of
									all
									previous rounds, with previous rounds being exponentially decayed.  That
									is, the <a href="#db-past-currentsp1"><var>currentsp1</var></a> plus
									half of the last round's weighted average and so on.
									If a round does not have enough plays by either player role to produce
									payoffs, it is omitted from the accumulation sequence.
									This is recorded as a space-separated sequence of rational numbers, one
									per strategy.
								</dd>
								<dt id="db-past-averagesp2"><var>averagesp2</var></dt>
								<dd>
									Like <a href="#db-past-averagesp1"><var>averagesp1</var></a> but for the
									column player.
								</dd>
								<dt id="db-past-currentsp1"><var>currentsp1</var></dt>
								<dd>
									For the row player, the average strategy mixture of the current round.
									Strategy mixtures are only considered for <a
										href="#db-choice"><code>choice</code></a> rows where the <a
										href="#db-player"><code>player</code></a> played all games
									for the round, so this will be a set of zeroes if no players completed
									all games.
									This is recorded as a space-separated sequence of rational numbers, one
									per strategy.
								</dd>
								<dt id="db-past-currentsp2"><var>currentsp2</var></dt>
								<dd>
									Like <a href="#db-past-currentsp1"><var>currentsp1</var></a> but for the
									column player.
								</dd>
								<dt id="db-past-gameid"><var>gameid</var></dt>
								<dd>
									A foreign key reference to the <a href="#db-game"><code>game</code></a>
									<a href="#db-game-id"><var>id</var></a>.
								</dd>
								<dt id="db-past-id"><var>id</var></dt>
								<dd>
									Unique identifier.
								</dd>
								<dt id="db-past-plays"><var>plays</var></dt>
								<dd>
									The total number of plays that were submitted (over all games) in this
									round if and only if the player submitted for all games in that round.
								</dd>
								<dt id="db-past-round"><var>round</var></dt>
								<dd>
									The round starting at zero.
								</dd>
								<dt id="db-past-roundcount"><var>roundcount</var></dt>
								<dd>
									The accumulated count of rounds not skipping, i.e., the count of zero-valued
									<a href="#db-past-skip"><var>skip</var></a> rounds.  This is used for
									computing the accumulated weighted average, which is really the sum of
									all (non-zero) weighted previous rounds divided by the exponential
									sum.
								</dd>
								<dt id="db-past-skip"><var>skip</var></dt>
								<dd>
									If zero row or column players played all games, this is set to
									<var>1</var>, else it is <var>0</var> (sufficient players played).
								</dd>
							</dl>
						</dd>
						<dt id="db-smtp"><code>smtp</code></dt>
						<dd>
							<p>
								This consists of the SMTP server information used in sending e-mails.
								There is always only one row set, which defaults to empty values (see <a
									href="#db-smtp-isset"><var>isset</var></a>).
							</p>
							<dl>
								<dt id="db-smtp-user"><var>user</var></dt>
								<dd>The SMTP server username (used for logging in).</dd>
								<dt id="db-smtp-email"><var>email</var></dt>
								<dd>The e-mail address used as the <q>From</q> address in all communication from
									the server to players and the experimenter.
									It is usually the same as the experimenter <a
										href="#db-admin-email"><var>email</var></a> set in the <a
										href="#db-admin"><code>admin</code></a> table, but may be set as
									a standard <q>No-Reply</q>. (This is discouraged, as your players should
									be able to reply to you if things go wrong.)
								<dt id="db-smtp-pass"><var>pass</var></dt>
								<dd>The SMTP username's password (used for logging in).  <strong>Note</strong>
									that this is stored in cleartext, so make sure that your password isn't
									used elsewhere.</dd>
								<dt id="db-smtp-server"><var>server</var></dt>
								<dd>The SMTP server in <code>smtp://server:port</code> format.</dd>
								<dt id="db-smtp-isset"><var>isset</var></dt>
								<dd>Whether these entries have been set.</dd>
								<dt id="db-smtp-id"><var>id</var></dt>
								<dd>Unique identifier.</dd>
							</dl>
						</dd>
					</dl>
				</section>
			</section>
			<section id="api">
				<h2>Programmable API</h2>
				<p>
					As described in the <a href="#technicalities">Technicalities</a> section, <span
						class="nm">gamelab</span> is at heart a web application making JSON requests of a server.
					This JSON interface is simple and easy to use to create a programmatic interface.
					If you wish to create a programmatic interface (a <q>bot</q>), and your experimenter consents, it's a
					fairly easy process.
					In fact, a tool already exists within the <span class="nm">gamelab</span> source distributions to stress
					test systems using this interface.
				</p>
				<p>
					To do this, you'll need a programming language that has support for JSON and making HTTP requests.
					In C, you can use <a href="https://github.com/json-c/json-c/wiki">json-c</a> and <a
						href="http://curl.haxx.se/libcurl/">libCURL</a>, respectively.
				</p>
				<section id="generalseq">
					<h3>General Sequence</h3>
					<p>
						The general sequence is as follows:
					</p>
					<ol>
						<li>
							Get your username and password, or optionally, have your utility register with <a
								href="#seq-doautoadd">doautoadd.json</a> as a captive player
							and get a randomly-generated password.
						</li>
						<li>
							Wait for the experiment to accept players by polling <a
								href="#seq-dologin">dologin.json</a> in order to login.
						</li>
						<li>
							Log in to <a href="#seq-dologin">dologin.json</a> with your username and password,
							accepting your session identifier as cookies.
						</li>
						<li>
							Wait for the experiment to begin by polling <a
								href="#seq-doloadexpr">doloadexpr.json</a>.
							Use your session identifier as an identifier cookie.
						</li>
						<li>
							Accept the experiment data from <a href="#seq-doloadexpr">doloadexpr.json</a>.
							Use your session identifier as an identifier cookie.
						</li>
						<li>
							Using the experiment data from <a href="#seq-doloadexpr">doloadexpr.json</a>,
							construct and submit a series of game plays to <a href="#seq-doplay">doplay.json</a>.
							Use your session identifier as an identifier cookie.
						</li>
						<li>
							Wait for the next round, or end of game, by polling polling <a
								href="#seq-doloadexpr">doloadexpr.json</a>.
							Use your session identifier as an identifier cookie.
						</li>
					</ol>
					<p>
						Do not flood the system with requests: be considerate!
						Unless specifically stipulated by the experimenter, you are not rewarded for fast play.
						Avoid re-connecting with anything less than 30&#8211;60 seconds between attempts, unless specifically
						allowed by an administrator, or your bot may be banned from the experiment.
					</p>
				</section>
				<section id="resources">
					<h3>Resources</h3>
					<p>
						This section describes the resources (URLs) that may be accessed for programmatic play.
						Each of these resources is the immediate path following the laboratory CGI script name, for
						example, if you're running as <span class="file">localhost/lab.cgi</span>, these would be mapped
						to <span class="file">localhost/lab.cgi/doautoadd.json</span>.
					</p>
					<dl>
						<dt id="seq-doautoadd">doautoadd.json (POST)</dt>
						<dd>
							Post your e-mail address using the <code>ident</code> field name.
							Returns HTTP error code 
							400 (invalid or missing e-mail field), 
							403 (player by that e-mail already exists),
							404 (captive players disallowed), or
							200 (success).
							Upon success, the return body is a JSON object consisting of the <code>ident</code> and
							<code>password</code> string fields.
						</dd>
						<dt id="seq-dologin">dologin.json (POST)</dt>
						<dd>
							Post your e-mail address (or identifier) and password using the <code>ident</code> and
							<code>password</code> field names.
							Returns HTTP error code
							400 (invalid or missing input fields),
							409 (experiment not started yet), 
							200 (success).
							If you receive HTTP error code 409, wait and continue polling: the experiment is not yet
							accepting player logins.
							Upon success, the return body is empty, but the cookie field consists of
							<code>sessid</code>, your session identifiers (a number); and <code>sesscookie</code>, a
							magic number attached to your identifier.
						</dd>
						<dt id="seq-doloadexpr">doloadexpr.json (GET)</dt>
						<dd>
							Get a JSON object describing the full experiment.
							You will need to pass the <code>sessid</code> and <code>sesscookie</code> cookie fields
							as described in <a href="#seq-dologin">dologin.json</a>.
							Returns HTTP error code
							304 (not changed since last request),
							409 (experiment not started yet),
							429 (player accepted, but not yet joined for play),
							200 (success).
							If you receive HTTP error code 409 or 429, wait and continue polling: the experiment is
							not yet started or has started, but you are not allowed to join yet.
							Upon success, returns the JSON experiment object.
						</dd>
						<dt id="seq-doplay">doplay.json (POST)</dt>
						<dd>
							Post a probability mixture for a game's actions.
							You will need to pass the <code>sessid</code> and <code>sesscookie</code> cookie fields
							as described in <a href="#seq-dologin">dologin.json</a>.
							The game identifier and round must be encoded in the <code>gid</code> and
							<code>round</code> fields, respectively.
							Each action with a requested probability must be posted as field <code>indexNNN</code>,
							where <code>N</code> is the action index (starting at zero), e.g.,
							<code>index0</code>, <code>index1</code>, and so on.
							Probabilities may be decimal or fractional strings.
							Missing actions are assigned zero probability.
							Actions greater than the maximum action are ignored.
							Returns HTTP error code
							400 (invalid game, round, or probability, or probability sum doesn't equal one), 
							409 (round has passed or is being played again, experiment hasn't started or has
							finished, or player hasn't joined), or
							200 (success).
							<strong>Note</strong>: the error codes for this resource are likely to become more
							specific in future releases.
						</dd>
					</dl>
				</section>
				<section id="objects">
					<h3>Objects</h3>
					<p>
						This section needs to be written.
					</p>
				</section>
			</section>
		</article>
		<footer>
			<div>
				&copy; 2015, <a href="http://www.kcons.eu"><i>k</i>-Consulting</a>
			</div>
			<div>
				Powered by <a href="http://kristaps.bsd.lv/sblg">sblg</a> on <a href="http://www.openbsd.org">OpenBSD</a>
			</div>
		</footer>
	</body>
</html>
